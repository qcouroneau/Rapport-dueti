= Le projet FinanceJ

Durant la seconde session, j'ai pu travailler sur un projet de maintenance informatique, grâce au cours LOG240 "Tests et maintenance".

NOTE: Je vais ici m'attarder sur ce que j'ai pu découvrir comme méthodes et outils de conception et de développement. Je ne vais pas pour autant négliger ce que j'ai déjà pu voir à l'IUT, mais je pense qu'il est plus pertinent de vous présenter ce que j'ai pu apprendre.

== Introduction

La firme de consultation MaintenancePlus, qui est un spécialiste dans la maintenance et
le test de logiciels, vient d’assigner à mon équipe son premier contrat de travail.
La situation de l’entreprise BudgetPersonnel2000, pour laquelle MaintenancePlus
requiert vos services, est la suivante :

* BudgetPersonnel2000 est une entreprise qui vend des services à des particuliers afin de les aider à gérer leur budget
* Il y a un an, l’un de ses gestionnaires a eu l’idée de développer un logiciel que l’entreprise pourrait vendre à ses clients pendant les rencontres, afin de générer plus de bénéfices
* Une tierce personne à donc été embauchée par BudgetPersonnel2000 pour développer et assurer la maintenance de son logiciel, qu’elle a dénommé FinanceJ.
* Ayant trouvé un autre emploi, cette tierce personne vient de quitter son poste à BudgetPersonnel2000 qui se presse alors de recueillir les services de la firme MaintenancePlus pour assurer désormais la maintenance de FinanceJ.

L’état du logiciel FinanceJ n’est pas reluisant. Ses utilisateurs trouvent qu’il n’est pas assez
convivial, qu’il exécute des opérations qui peuvent briser l’intégrité de la base de
données, et que certaines de ses fonctionnalités ne s’exécutent même pas. Votre équipe
a donc la mission de le prendre en charge le logiciel dans un environnement de
maintenance réel pour pouvoir l’améliorer, conformément aux normes qui régissent le
domaine.

image:image/.jpg[width=450]

Le but du projet est donc de reprendre cette application, et de l'améliorer pour l'enmener vers une version utilisable.

== Demande client

Le projet commence par une phase une demande client. Il est ainsi demandé à l’équipe de développement d’apporter des modifications apportant de nouvelles  fonctionnalités à l’application. Ces modifications devant apporter “un système de droit d'accès au logiciel (login, mot de passe avec différent droit)”.

== Conception

Tout d'abord l'équipe se porte sur la documentation du logiciel FinanceJ. La demande de changement du client, l’implémentation de ce changement ainsi que l’amélioration de quelques classes qui posent présentement problème pour le bon fonctionnement de ce programme.

Trois fonctionnalités majeures ont donc été définies à partir de cette demande.

Un système d’authentification (fenêtre prévue à cet effet) comprenant :

* Une création d’utilisateurs (login + password).
* La correspondance de la pair login password avec database pour se connecter à l’application.
* La suppression d’utilisateur.

Un Système d'attribution de droits (fenêtre prévue à cet effet) :

* Master user capable de donner des droits aux autres users.
* Master user capable de supprimer des droits aux autres users.

Limitation du logiciel en fonction des droits (partie non visible des modifications) :

* Accès à certaines parties du logiciel en fonction des droits.
* Accès à certaines fonctionnalités en fonction des droits (tout le monde ne doit pas pouvoir supprimer des utilisateurs / transaction / etc…).

=== Cas d'utilisation

Pour cela, l'équipe de developpement à tout d'abord établie plusieurs cas d'utilisation. Ces cas d'utilisations vont permettre de définir les principales manière d'utiliser le logiciel. Grâce à cela il va être plus simple de définir comment parvenir à une bonne utilisation du logiciel et quelles seront les conséquences de cette utilisation. Ils comprenent chacuns quatres parties. 

La prmière etant les preconditions, on regroupe ici toutes les conditions qui permettent à l'utilisateur d'effectue l'action voulue. 

Exemple : pour ajouter un champ dans une base de données. Ici nous allons prendre l'exemple de l'ajout d'un compte dans la base. Compte qui comprend un nom et une description. L'utilisateur doit donc être connecté au logiciel et dans l'onglet d'ajout.

La deuxième partie regroupe les post-conditions. Ici ce sont toutes les conditions qui permettent d'affirmer que l'utilisation voulue s'est bien déroulée. Par exemple, si l'on reprend l'exemple de l'ajout du compte dans la base, une post-condition serait qu'un nouveau compte a bien été ajouté dans la base.

La troisième partie est composé du scénario principal. Celui-ci regoupe l'ensemble des actions utilisateur qui composent l'utilisation voulue. Toujours avec l'exemple de l'ajout du compte dans la base. On va par exemple s'attendre que l'utilisateur remplissent les champs comme le nom et la description, ou encore qu'il appuit sur le boutton d'ajout. 

Enfin la dernière partie regroupe les scénarios alternatifs. Comme pour le scénario principal c'est une suite d'actions qui composent une utilisation. Mais ici ce n'est pas l'utilisation principale de la fonction logiciel traitée. Généralement on regroupe ici les cas qui peuvent amener à une erreure (mais pas uniquement). Avec l'exemple de l'ajout du compte dans la base. Un scénario alternatifs serait de tenter d'ajouter un compte dans la base sans avoir renseigné le nom, ce qui va mener à message 

=== Diagramme de séquence

Suite aux cas d'utilisation et surtout grâce au scenario principal, il va être assez simple de produire des diagrammes de séquence. Ceux-ci vont representer les interactions entre les acteurs et le système selon un ordre chronologique. 

.Diagramme de séquence de l'ajout d'un ajout dans la base
image::image/diagSeq.png[Diagramme de séquence]

Ici nous pouvont voir comment fonctionne l'ajout d'un champ dans la bases (ici le champ Ledger). L'utilisateur appuit sur le bouton d'ajout correspondant à la classe en question. Celle-ci va communiquer avec la classe chargée de la communication de la base de donnees qui va enfin inserer le nouveau champ dans la base.

== Test de boite noire

Maintenant que toutes les modifications
Les test de boite noire sont prévue pour tester un programme en vérifiant que les sorties obtenues sont bien celles prévues pour des entrées données.

=== Valeurs frontalières

Avant de commencer la conception des tests, nous allons d'abord définir les "valeurs frontalières".

Ces valeurs frontalières sont les valeurs qui sont aux limites de la créations d'erreurs dans le logiciel. Par exemple si une variable ne peut dépasser 50 caractères, les valeurs frontalière sont 50 car jusque là il n'est pas censé avoir d'erreur. Et 51 car c'est à partir de là que le logiciel va produire une erreur (cet exemple est simplifié, il y a en général plus de valeurs frontalière par variable).

=== Classes d'équivalence

Une fois toutes les valeurs frontalières définit, nous produisont un tableau de classes d’équivalence. Le but d'une classe d'équivalence est de prendre une valeur frontalière définit plus tôt et de lui attribuer une validité ou non. C'est-à-dire, pour tel valeur de la variable est-ce-que la fonction va réussir à effectuer ce pourquoi elle programmée.

Le tableau de classes d'équivalence va donc permettre de définir une validité (ou non) pour chacune des valeurs frontalières.

.Extrait d'une classe d'équivalence
image::image/classeEqui.png[Diagramme de classe]

Nous pouvons voir, de gauche à droite :

* le nom de la variable concerné.
* Une description de cette variable.
* L'identificateur que l'on donne à cette classe d'équivalence.
* La valeur frontalière concerné.
* La validité du programme avec cette valeur.
* Une description permettant de comprendre la validité ou non de cette classe d'équivalence.

=== Cas de tests

Grâce aux classes d’équivalence, des tableaux de tests seront établies. Ces tableaux permettront d’établir les tests qui seront implémentés en reprenant les valeurs frontalières des classes d’équivalence. Voici un extrait d'un tableau de test :

.Extrait d'un tableau de cas de test
image::image/casDeTest.png[Cas de test]

Nous pouvons voir, de gauche à droite :

* Le nom du test
* Les préconditions pour effectuer le test
* Les post-conditions permettant de définir si le test s'est bien déroulé
* Les entrées des variables (ici on veut qu'à l'entrée de la fonction, la variable "Name" ai plus de 50 caractères)
* L'identificateur de la classes d'équivalence définit plutôt. On met ici toutes les classes d'équivalence valides, c'est-à-dire celle qui ne produisent pas d'erreur. Dans ce cas, nous avons au moins 1 caractère alphanumérique (EC1), une longueur plus petite ou égale à 50 (EC2), etc...
* L'identificateur de la classes d'équivalence définit plutôt. On met ici toutes les classes d'équivalence invalides, c'est-à-dire celle qui produisent des erreur (cette colonne peut être vide si le test à pour but de ne pas produire d'erreur). Dans notre cas, nous avons une longueur plus longue que 50 (EC4), ce qui va produire une erreur.
* La sortie système obtenue. Ici c'est ce que le logiciel va retourner à l'utilisateur dans le terminal.
* Une description permettant d'expliquer le déroulement du test

Le but de ces cas de tests est de couvrir toutes les classes d'équivalence invalides pour être sûr de tester toutes les cas d'erreur possible (ou au moins ceux definit par l'équipe) tout en evitant la redondance. Une fois toutes les classes d'équivance invalide traitées, il ne reste plus qu'à les implémenter.

== Réingénierie dirigée par les tests



== Développement

Nous allons ici nous attarder sur les principaux outils de developpement utilises. Nous verrons ensuite les resultats de la phase de programmation. La programmation en elle même n'etant pas très interessante (programmation classqiue en java EE). 

NOTE: En ce qui concerne la chronologie du projet, la phase de developpement n'a pas debutee après la phase de conception prsenté plus tôt. Elle était en réalité faite en parrallèle. Cependant elle comprenait des parties de developpement mineurs qui non pas necessite de la conception. Comme de la correction ou de l'optimisation de code. C'est pendant ces phases de developpement mineur que nous avons travaillé sur la conception. Je vais donc ici m'attarder sur les points centraux du developpement.

=== Trac

Avant de se lancer dans la programmation, nous avons mis en place un service Trac. 

Trac est un wiki amélioré et un système de suivi des problèmes pour les projets de développement logiciel. Il fournit une interface à Git (ou d’autres systèmes de contrôle de version), un wiki intégré et des fonctions de rapport pratiques. Trac permet de baliser le wiki dans les descriptions de problème et de valider des messages, en créant des liens et des références transparentes entre les bogues, les tâches, les ensembles de modifications, les fichiers et les pages wiki. Une chronologie affiche dans l'ordre tous les événements de projet actuels et passés, ce qui facilite l'acquisition d'une vue d'ensemble du projet et le suivi de ses progrès. La feuille de route indique la voie à suivre, en énumérant les jalons à venir.

Trac permet aussi de mettre au point des "tickets" : ce sont des representation des tâches à effectuer.

// trac billet

On peut ainsi nottament y voir : la ou les personnes assignes à cette tâche, la priorité de la tâche ou encore le jalon auquel le ticket appartient. 

Dans ce projet, Trac va servir de plateforme principale pour tout ce qui tourne autour de la programmation :

* Elle va regrouper une partie de la documentation. C'est par exemple tout ce qui touche à la conception ou au fonctionnement du logiciel. 
* Elle permet de revoyer vers le git du projet, mais aussi vers les rapport PMD (que nous allons voir juste après).
* Elle regroupe les tickets en cours et ceux realises 

Une fois cet outil mit en place, nous nous sommes tournes vers la mise en place de QALab.

=== QALab

QALab est un plugin de Maven, il permet de genrer de la documentation 

Nous avons avant tout utilises deux outils de QALab :

*Checkstyle* : qui permet une validation du style de code et une vérification de la conception. 

// image Checkstyle

Ceci est le résultat d’une session de correctifs d’erreurs décelées par Checkstyle. Chacune de ces classes
présentait un certain nombre d’erreurs, elles sont présentes dans la colonne Previous Value. On peut
ensuite voir que pour la version actuelle du projet, ici celle du 25 janvier 2019, le nombre d’erreurs à
baisser. Le nouveau nombre d’erreurs est situé dans la classe Current Value. Nous avons donc sept
classes java qui ont perdu au moins une erreur chacune dans leur code.

*PMD* : Vérification du code (bugs possibles, code mort, code sous-optimal, etc.).

// image PMD

Même explication ici, dans la partie Up by, nous pouvons voir les classes qui comportent des erreurs dans
leur code, mais qui n’ont pas été modifiées lors de la précédente mise à jour du projet.
Dans la partie Down by, nous pouvons voir que les correctifs de la dernière mise à jour se sont concentrés
sur des erreurs repérées par PMD dans la classe DBUtils.java. En effet, lors de la précédente version du
projet, le nombre d’erreurs (Previous Run) était de 19. Après les correctifs apportés par la dernière
version du projet, le nombre d’erreurs est passé à 7 (Current Value).

Pour chacun de ces deux outils, QALab va generer des diagrammes permettant de voir l'etat actuel du projet. Que ce soit le nombre d'erreur actuel, mais aussi le nombre d'erreur dans les version precedentes du projet. 

// image QALab 

Ici, nous pouvons voir les différentes sessions de corrections d’erreurs. Tout d’abord, le code possédait
1524 erreurs détectées par _Checkstyle_, ainsi que 131 erreurs détectées par _PMD_. Après la première session
de correctifs que nous avons apportés, les erreurs de type _CheckStyle_ sont passé de 1524 à 1512. Nous
avons ensuite corrigé des erreurs soulevées par _PMD_, elles sont ainsi passées de 131 à 119, on peut
cependant noter qu’une nouvelle erreur a été détectée par _Checkstyle_.

=== Maven

